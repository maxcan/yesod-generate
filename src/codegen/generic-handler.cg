{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Handler.~{modelNameUpper} 
  ( get~{modelNameUpper}R
  , post~{modelNameUpper}NewR
  , get~{modelNameUpper}NewR
  , post~{modelNameUpper}EditR
  , get~{modelNameUpper}EditR
  , post~{modelNameUpper}DeleteR
  , get~{modelNameUpper}DetailR
  )
  where

import Import
import qualified Data.Text as DT

-- | The optionsPersist builtin to the Yesod.Forms package unfortunately only
--   works well with whole persist entities.  We are only interested in the entity
--   id s which is why we add in this function here:
optionsPersistKey
  :: (YesodPersist master
     , PersistEntity a
     , PersistQuery (YesodPersistBackend master) (GHandler sub master)
     , PathPiece (Key (YesodPersistBackend master) a)
     , RenderMessage master msg
     , PersistEntityBackend a ~ YesodPersistBackend master) 
  => [Filter a] 
  -> [SelectOpt a] 
  -> (Entity a -> msg) 
  -> GHandler sub master (OptionList (Key (PersistEntityBackend a) a))
optionsPersistKey filts ords toDisplay = fmap mkOptionList $ do
    mr <- getMessageRender
    pairs <- runDB $ selectList filts ords
    return $ map (\(Entity key value) -> Option
        { optionDisplay = mr (toDisplay $ Entity key value)
        , optionInternalValue = key
        , optionExternalValue = toPathPiece key
        }) pairs

~{modelNameLower}Form :: Maybe ~{modelNameUpper} -> Form ~{modelNameUpper}
~{modelNameLower}Form m~{modelNameUpper} = ~{renderFxn} $ ~{modelNameUpper}
~{generatedFormFields}

get~{modelNameUpper}R        :: Handler RepHtmlJson
post~{modelNameUpper}NewR    :: Handler RepHtml
get~{modelNameUpper}NewR     :: Handler RepHtml

post~{modelNameUpper}EditR   :: ~{modelNameUpper}Id -> Handler RepHtml
get~{modelNameUpper}EditR    :: ~{modelNameUpper}Id -> Handler RepHtml
post~{modelNameUpper}DeleteR :: ~{modelNameUpper}Id -> Handler RepHtml
get~{modelNameUpper}DetailR  :: ~{modelNameUpper}Id -> Handler RepHtmlJson

get~{modelNameUpper}R = do
  (all~{modelNameUpper}s :: [Entity ~{modelNameUpper}]) <- runDB $ selectList [] []
  defaultLayoutJson $(widgetFile "~{modelNameLower}/index") all~{modelNameUpper}s

post~{modelNameUpper}NewR = do
  ((formResult, _), _) <- runFormPost $ ~{modelNameLower}Form Nothing
  case formResult of
    FormSuccess ~{modelNameLower} -> do
      ~{modelNameLower}Id <- runDB $ insert ~{modelNameLower}
      setMessage "successfully added"
      redirect $ ~{modelNameUpper}DetailR ~{modelNameLower}Id
    _ -> do 
      setMessage "form error"
      redirect ~{modelNameUpper}NewR
    
get~{modelNameUpper}NewR = do
  ((_, formWidget), enctype) <- generateFormPost $ ~{modelNameLower}Form Nothing
  defaultLayout $(widgetFile "~{modelNameLower}/new")
    
post~{modelNameUpper}EditR ~{modelNameLower}Id = do
  ((formResult, _), _) <- runFormPost $ ~{modelNameLower}Form Nothing
  case formResult of
    FormSuccess ~{modelNameLower} -> do
      _ <- runDB $ replace ~{modelNameLower}Id ~{modelNameLower}
      setMessage "successfully replaced"
    _ -> setMessage "form error"
  redirect $ ~{modelNameUpper}DetailR ~{modelNameLower}Id

get~{modelNameUpper}EditR ~{modelNameLower}Id = do
  ~{modelNameLower} <- runDB $ get404 ~{modelNameLower}Id
  ((_, formWidget), enctype) <- generateFormPost $ ~{modelNameLower}Form (Just ~{modelNameLower})
  defaultLayout $(widgetFile "~{modelNameLower}/edit")

post~{modelNameUpper}DeleteR ~{modelNameLower}Id = do 
  _ <- runDB $ get404 ~{modelNameLower}Id
  runDB $ delete ~{modelNameLower}Id
  setMessage . toHtml $ DT.concat ["Deleted ~{modelNameUpper} with id: ", toPathPiece ~{modelNameLower}Id]
  redirect ~{modelNameUpper}R

get~{modelNameUpper}DetailR ~{modelNameLower}Id = do
  ~{modelNameLower} <- runDB $ get404 ~{modelNameLower}Id
  defaultLayoutJson $(widgetFile "~{modelNameLower}/show") (Entity ~{modelNameLower}Id ~{modelNameLower})

